import{_ as l,c as t,o as a,s as r}from"./chunks/framework.C0aFDVig.js";const u=JSON.parse('{"title":"小程序通过URL Scheme进入页面，对登陆的改造","description":"","frontmatter":{},"headers":[{"level":1,"title":"小程序通过URL Scheme进入页面，对登陆的改造","slug":"小程序通过url-scheme进入页面-对登陆的改造","link":"#小程序通过url-scheme进入页面-对登陆的改造","children":[{"level":2,"title":"现存可能进入的环境","slug":"现存可能进入的环境","link":"#现存可能进入的环境","children":[]},{"level":2,"title":"改造方式","slug":"改造方式","link":"#改造方式","children":[]}]}],"relativePath":"articles/工作文档/项目/小程序通过URL Scheme进入页面，对登陆的改造.md","filePath":"articles/工作文档/项目/小程序通过URL Scheme进入页面，对登陆的改造.md"}'),c={name:"articles/工作文档/项目/小程序通过URL Scheme进入页面，对登陆的改造.md"};function i(o,e,s,_,h,n){return a(),t("div",null,e[0]||(e[0]=[r('<h1 id="小程序通过url-scheme进入页面-对登陆的改造" tabindex="-1">小程序通过URL Scheme进入页面，对登陆的改造 <a class="header-anchor" href="#小程序通过url-scheme进入页面-对登陆的改造" aria-label="Permalink to &quot;小程序通过URL Scheme进入页面，对登陆的改造&quot;">​</a></h1><blockquote><p>为了兼容从其他环境进入小程序某个页面，登陆后跳转回对应页面的改造</p></blockquote><h2 id="现存可能进入的环境" tabindex="-1">现存可能进入的环境 <a class="header-anchor" href="#现存可能进入的环境" aria-label="Permalink to &quot;现存可能进入的环境&quot;">​</a></h2><ul><li>扫码</li><li>分享的链接</li><li>URL Scheme</li></ul><h2 id="改造方式" tabindex="-1">改造方式 <a class="header-anchor" href="#改造方式" aria-label="Permalink to &quot;改造方式&quot;">​</a></h2><ol><li><s>在请求拦截时，记录当前所在页面，所有页面，如果访问任何页面401时，跳转登陆后，都应该回到原来的页面。</s></li><li>在请求拦截时，跳转登陆页面的方式改为<code>router.to</code>，不再是<code>redirectTo</code>，在登陆完成后，首先考虑是否可以<code>this.router.back({number})</code>，如果可以的话，则退回来的页面，如果抛出了错误，那么就延用原来的逻辑<code>this.router.reLaunch(&#39;/pages/index/index&#39;)</code>跳转到首页。这种方式，可以兼容其他方式及页面进入小程序需要登录的需求</li></ol><p>#电信</p>',7)]))}const m=l(c,[["render",i]]);export{u as __pageData,m as default};
